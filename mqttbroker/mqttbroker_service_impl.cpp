/* mqttbroker_service_impl.cpp

 Generated by phxrpc_pb2service from mqttbroker.proto

*/

#include "mqttbroker_service_impl.h"

#include "phxrpc/file.h"

#include "mqtt/mqtt_msg.h"
#include "mqttbroker.pb.h"
#include "mqttbroker_server_config.h"


using namespace std;


MqttBrokerServiceImpl::MqttBrokerServiceImpl(ServiceArgs_t &app_args,
        phxrpc::UThreadEpollScheduler *const worker_uthread_scheduler,
        phxrpc::DataFlowArgs *data_flow_args)
        : args_(app_args),
          worker_uthread_scheduler_(worker_uthread_scheduler),
          data_flow_args_(data_flow_args) {
}

MqttBrokerServiceImpl::~MqttBrokerServiceImpl() {
}

int MqttBrokerServiceImpl::PHXEcho(const google::protobuf::StringValue &req,
                                   google::protobuf::StringValue *resp) {
    resp->set_value(req.value());

    return 0;
}

int MqttBrokerServiceImpl::PhxHttpPublish(const phxqueue_phxrpc::mqttbroker::HttpPublishPb &req,
                                          phxqueue_phxrpc::mqttbroker::HttpPubackPb *resp) {
    // publish to event_loop_server
    auto *publish(new phxqueue_phxrpc::mqttbroker::MqttPublish);
    publish->FromPb(req.mqtt_publish());
    // TODO: gen sub_packet_id
    // ack_key = sub_client_id + sub_packet_id
    const string sub_client_id("test_sub");
    const auto sub_packet_id = (req.session_id() % 0xFFFF);
    const string ack_key = sub_client_id + '_' + to_string(sub_packet_id);
    publish->set_packet_identifier(sub_packet_id);

    if (1 == req.mqtt_publish().qos()) {
        void *data{nullptr};
        args_.server_mgr->SendAndWaitAck(req.session_id(), publish, worker_uthread_scheduler_,
                                         ack_key, data);

        phxqueue_phxrpc::mqttbroker::MqttPuback *puback{(phxqueue_phxrpc::mqttbroker::MqttPuback *)data};
        if (!puback) {
            printf("%s server_mgr.SendAndWaitAck nullptr session_id %" PRIx64
                   " qos %u ack_key \"%s\"\n", __func__, req.session_id(),
                   req.mqtt_publish().qos(), ack_key.c_str());

            return -1;
        }

        printf("%s server_mgr.SendAndWaitAck session_id %" PRIx64
               " qos %u ack_key \"%s\"\n", __func__, req.session_id(),
               req.mqtt_publish().qos(), ack_key.c_str());

        resp->set_session_id(req.session_id());
        phxrpc::ReturnCode ret_code{puback->ToPb(resp->mutable_mqtt_puback())};

        delete puback;

        if (phxrpc::ReturnCode::OK != ret_code) {
            return static_cast<int>(ret_code);
        }
    } else {
        args_.server_mgr->Send(req.session_id(), publish);
        printf("%s server_mgr.Send session_id %" PRIx64 " qos %u\n", __func__, req.session_id(), req.mqtt_publish().qos());
    }

    return 0;
}

int MqttBrokerServiceImpl::PhxMqttConnect(const phxqueue_phxrpc::mqttbroker::MqttConnectPb &req,
                                          phxqueue_phxrpc::mqttbroker::MqttConnackPb *resp) {
    const auto &old_mqtt_session(args_.mqtt_session_mgr->GetByClientId(
            req.client_identifier()));
    SessionMgr *session_mgr{(SessionMgr *)(data_flow_args_->session_mgr)};
    if (old_mqtt_session) {
        if (old_mqtt_session->session_id == data_flow_args_->session_id) {
            // mqtt-3.1.0-2: disconnect current connection

            args_.mqtt_session_mgr->DeleteBySessionId(data_flow_args_->session_id);
            session_mgr->DeleteBySessionId(data_flow_args_->session_id);

            printf("%s err session_id %" PRIx64 " client_id \"%s\"\n",
                   __func__, data_flow_args_->session_id, req.client_identifier().c_str());

            return -1;
        } else {
            // mqtt-3.1.4-2: disconnect other connection with same client_id
            args_.mqtt_session_mgr->DeleteBySessionId(old_mqtt_session->session_id);
            session_mgr->DeleteBySessionId(old_mqtt_session->session_id);

            printf("%s disconnect session_id old %" PRIx64 " new %" PRIx64 " client_id \"%s\"\n",
                   __func__, old_mqtt_session->session_id, data_flow_args_->session_id,
                   req.client_identifier().c_str());
        }
    }

    // mqtt connect: set client_id and init
    const auto &mqtt_session(args_.mqtt_session_mgr->Create(
            req.client_identifier(), data_flow_args_->session_id));
    mqtt_session->keep_alive = req.keep_alive();
    //session.clean_session = req.clean_session();
    //session.user_name = req.user_name();
    //session.password = req.password();
    //session.will_flag = req.will_flag();
    //session.will_qos = req.will_qos();
    //session.will_retain = req.will_retain();
    //session.will_topic = req.will_topic();
    //session.will_message = req.will_message();
    mqtt_session->Heartbeat();

    resp->set_session_present(!req.clean_session());
    resp->set_connect_return_code(0u);

    printf("%s session_id %" PRIx64 " client_id \"%s\"\n",
           __func__, data_flow_args_->session_id, req.client_identifier().c_str());

    return 0;
}

int MqttBrokerServiceImpl::PhxMqttPublish(const phxqueue_phxrpc::mqttbroker::MqttPublishPb &req,
                                          google::protobuf::Empty *resp) {
    if (1 == req.qos()) {
        phxqueue_phxrpc::mqttbroker::MqttPubackPb puback_pb;
        puback_pb.set_packet_identifier(req.packet_identifier());
        auto *puback(new phxqueue_phxrpc::mqttbroker::MqttPuback);
        puback->FromPb(puback_pb);
        args_.server_mgr->Send(data_flow_args_->session_id, (phxrpc::BaseResponse *)puback);
    }

    printf("%s session_id %" PRIx64 " qos %u packet_id %d topic \"%s\" content \"%s\"\n",
           __func__, data_flow_args_->session_id, req.qos(), req.packet_identifier(),
           req.topic_name().c_str(), req.content().c_str());

    return 0;
}

int MqttBrokerServiceImpl::PhxMqttPuback(const phxqueue_phxrpc::mqttbroker::MqttPubackPb &req,
                                         google::protobuf::Empty *resp) {
    auto *puback(new phxqueue_phxrpc::mqttbroker::MqttPuback);
    phxrpc::ReturnCode ret_code{puback->FromPb(req)};
    if (phxrpc::ReturnCode::OK != ret_code) {
        delete puback;
        printf("session_id %" PRIx64 " packet_id %d FromPb err %d\n",
               data_flow_args_->session_id, req.packet_identifier(), static_cast<int>(ret_code));

        return static_cast<int>(ret_code);
    }

    // TODO: gen sub_packet_id
    // ack_key = sub_client_id + sub_packet_id
    const string sub_client_id("test_sub");
    const auto sub_packet_id = req.packet_identifier();
    const string ack_key = sub_client_id + '_' + to_string(sub_packet_id);
    // forward puback and do not delete here
    int ret{args_.server_mgr->Ack(ack_key, (void *)puback)};
    if (0 != ret) {
        printf("%s server_mgr.Ack err %d ack_key \"%s\"\n", __func__, ret, ack_key.c_str());

        return ret;
    }

    printf("%s session_id %" PRIx64 " packet_id %d\n",
           __func__, data_flow_args_->session_id, req.packet_identifier());

    return ret;
}

int MqttBrokerServiceImpl::PhxMqttPubrec(const phxqueue_phxrpc::mqttbroker::MqttPubrecPb &req,
                                         google::protobuf::Empty *resp) {
    return -1;
}

int MqttBrokerServiceImpl::PhxMqttPubrel(const phxqueue_phxrpc::mqttbroker::MqttPubrelPb &req,
                                         google::protobuf::Empty *resp) {
    return -1;
}

int MqttBrokerServiceImpl::PhxMqttPubcomp(const phxqueue_phxrpc::mqttbroker::MqttPubcompPb &req,
                                          google::protobuf::Empty *resp) {
    return -1;
}

int MqttBrokerServiceImpl::PhxMqttSubscribe(const phxqueue_phxrpc::mqttbroker::MqttSubscribePb &req,
                                            phxqueue_phxrpc::mqttbroker::MqttSubackPb *resp) {
    for_each(req.topic_filters().begin(), req.topic_filters().end(),
            [resp](const string &s) {
                resp->add_return_codes(0u);
                printf("topic %s\n", s.c_str());
            });

    printf("%s session_id %" PRIx64 " packet_id %d\n",
           __func__, data_flow_args_->session_id, req.packet_identifier());

    return 0;
}

int MqttBrokerServiceImpl::PhxMqttUnsubscribe(const phxqueue_phxrpc::mqttbroker::MqttUnsubscribePb &req,
                                              phxqueue_phxrpc::mqttbroker::MqttUnsubackPb *resp) {
    for_each(req.topic_filters().begin(), req.topic_filters().end(),
            [](const string &s) {
                printf("topic %s\n", s.c_str());
            });

    printf("%s session_id %" PRIx64 " packet_id %d\n",
           __func__, data_flow_args_->session_id, req.packet_identifier());

    return 0;
}

int MqttBrokerServiceImpl::PhxMqttPing(const phxqueue_phxrpc::mqttbroker::MqttPingreqPb &req,
                                       phxqueue_phxrpc::mqttbroker::MqttPingrespPb *resp) {
    const auto &mqtt_session(args_.mqtt_session_mgr->GetBySessionId(data_flow_args_->session_id));
    mqtt_session->Heartbeat();

    printf("%s session_id %" PRIx64 "\n", __func__, data_flow_args_->session_id);

    return 0;
}

int MqttBrokerServiceImpl::PhxMqttDisconnect(const phxqueue_phxrpc::mqttbroker::MqttDisconnectPb &req,
                                             google::protobuf::Empty *resp) {
    args_.mqtt_session_mgr->DeleteBySessionId(data_flow_args_->session_id);
    SessionMgr *session_mgr{(SessionMgr *)(data_flow_args_->session_mgr)};
    session_mgr->DeleteBySessionId(data_flow_args_->session_id);

    printf("%s session_id %" PRIx64 "\n", __func__, data_flow_args_->session_id);

    return 0;
}

